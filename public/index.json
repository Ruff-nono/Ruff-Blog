[{"content":"1、什么是gin Gin 是一个用Go (Golang)编写的 开源web 框架。 目前在GitHub Start 47.4K, 它是一个类似于 martini 但拥有更好性能的 API 框架， 路由解析由于使用的是httprouter，速度提高了近 40 倍。\n2、安装 go get -u github.com/gin-gonic/gin 代码中导入\nimport \u0026#34;github.com/gin-gonic/gin\u0026#34; //（可选）导入net/http. 例如，如果使用常量，例如http.StatusOK. import \u0026#34;net/http\u0026#34; 3、启动服务 package main import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { r := gin.Default() r.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;pong\u0026#34;, }) }) r.Run() // listen and serve on 0.0.0.0:8080 (for windows \u0026#34;localhost:8080\u0026#34;) } 4、访问 D:\\\u0026gt;curl localhost:8080/ping {\u0026#34;message\u0026#34;:\u0026#34;pong\u0026#34;} ","permalink":"http://localhost:1313/posts/tech/gin/1-start/","summary":"1、什么是gin Gin 是一个用Go (Golang)编写的 开源web 框架。 目前在GitHub Start 47.4K, 它是一个类似于 martini 但拥有更好性能的 API 框架， 路由解析由","title":"gin框架(一)、快速入门"},{"content":"1、服务启动过程 func main() { r := gin.Default() r.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;pong\u0026#34;, }) }) r.Run() } 1. gin.Default() gin.Default() 函数会生成一个默认的 Engine 对象，里面包含了 2 个默认的常用插件，分别是 Logger 和 Recovery，Logger 用于输出请求日志， Recovery 确保单个请求发生 panic 时记录异常堆栈日志，输出统一的错误响应。\n// Default returns an Engine instance with the Logger and Recovery middleware already attached. func Default() *Engine { // 输出debug日志 debugPrintWARNINGDefault() // 创建一个默认无路由无中间件的引擎 engine := New() // 默认注册全局日志和异常捕获中间件 engine.Use(Logger(), Recovery()) return engine } Gin框架中注册中间件是通过 engine.Use(xx)的方式。\nginMode分为三种场景下的模式，默认为debug模式，可以通过环境变量或代码声明的方式修改模式\ndebugCode = iota releaseCode testCode [GIN-debug] [WARNING] Running in \u0026#34;debug\u0026#34; mode. Switch to \u0026#34;release\u0026#34; mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode) 2. engine.GET() router.Handle(httpMethod, relativePath, handlers) 用来创建路由，同时框架提供了 GET, POST 等简单方法，relativePath 和 handlers 分别与 router 中 basePath 、handlers 共同组成最终的 absolutePath 和 handlers。\n// Unless otherwise noted, these are defined in RFC 7231 section 4.3. const ( MethodGet = \u0026#34;GET\u0026#34; MethodHead = \u0026#34;HEAD\u0026#34; MethodPost = \u0026#34;POST\u0026#34; MethodPut = \u0026#34;PUT\u0026#34; MethodPatch = \u0026#34;PATCH\u0026#34; // RFC 5789 MethodDelete = \u0026#34;DELETE\u0026#34; MethodConnect = \u0026#34;CONNECT\u0026#34; MethodOptions = \u0026#34;OPTIONS\u0026#34; MethodTrace = \u0026#34;TRACE\u0026#34; ) // GET is a shortcut for router.Handle(\u0026#34;GET\u0026#34;, path, handle). // 注册一个匹配路径为 relativePath 的GET请求路由 func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes { return group.handle(http.MethodGet, relativePath, handlers) } // ----- func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes { //以\u0026#39;/\u0026#39;连接group.basePath 与 relativePath absolutePath := group.calculateAbsolutePath(relativePath) // 合并 group.Handlers 与 handlers handlers = group.combineHandlers(handlers) // 将请求路由添加到engine中 group.engine.addRoute(httpMethod, absolutePath, h andlers) return group.returnObj() } 3. engine.Run() // Run attaches the router to a http.Server and starts listening and serving HTTP requests. // It is a shortcut for http.ListenAndServe(addr, router) // Note: this method will block the calling goroutine indefinitely unless an error happens. func (engine *Engine) Run(addr ...string) (err error) { // 打印error日志 defer func() { debugPrintError(err) }() // 我们可以通过 router.SetTrustedProxies([]string{\u0026#34;192.168.1.2\u0026#34;}) 设置受信任的代理 if engine.isUnsafeTrustedProxies() { debugPrint(\u0026#34;[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\u0026#34; + \u0026#34;Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.\u0026#34;) } // 解析端口地址，默认使用环境变量PORT，或:8080 address := resolveAddress(addr) debugPrint(\u0026#34;Listening and serving HTTP on %s\\n\u0026#34;, address) // 监听端口地址，engine.Handler作为请求处理函数 err = http.ListenAndServe(address, engine.Handler()) return } 4.总结 Engine 是 Gin 框架的核心数据结构，通过 Engine 对象定义服务路由信息后，使用 http server 启动服务并监听端口地址。\nEngine 的本质只是对内置的 HTTP 服务器的包装，让它使用起来更加便捷。HTTP 服务器使用的是 Go 语言内置的 http server，\n2、结构体 classDiagram Engine --|\u003e RouterGroup RouterGroup --o Engine RouterGroup --|\u003e IRouter IRouter --|\u003e IRoutes Engine --o methodTree methodTree --o node class Engine{ +[]methodTree methodTrees +addRoute() +Run() +ServeHTTP() } class RouterGroup{ +Handlers HandlersChain -engine *Engine +Use() +Group() } class IRouter{ \u003c\u003einterface +Group *RouterGroup } class IRoutes{ \u003c\u003einterface +Use() +Handle() +GET() +POST() } class methodTree{ -string method -*node root } class node{ +string path +bool wildChild +uint8 nType +[]node children }\r1. gin.Engine Engine 是 Gin 框架最重要的数据结构，它是框架的入口。我们通过 Engine 对象来定义服务路由信息、组装插件、运行服务。 正如 Engine 的中文意思「引擎」一样，它就是框架的核心发动机，整个 Web 服务的都是由它来驱动的。\n// Engine is the framework\u0026#39;s instance, it contains the muxer, middleware and configuration settings. // Create an instance of Engine, by using New() or Default() type Engine struct { RouterGroup ... } 2. gin.RouterGroup RouterGroup 是 Engine 的父类，是对路由树的包装，所有的路由规则最终都是由它来进行管理。\n// RouterGroup is used internally to configure router, a RouterGroup is associated with // a prefix and an array of handlers (middleware). type RouterGroup struct { Handlers HandlersChain basePath string engine *Engine root bool } RouterGroup 实现了 IRoutes 接口，暴露了一系列路由方法，这些方法最终都是通过调用 Engine.addRoute 方法将请求处理器挂接到路由树中。\n// IRoutes defines all router handle interface. type IRoutes interface { Use(...HandlerFunc) IRoutes Handle(string, string, ...HandlerFunc) IRoutes Any(string, ...HandlerFunc) IRoutes GET(string, ...HandlerFunc) IRoutes POST(string, ...HandlerFunc) IRoutes DELETE(string, ...HandlerFunc) IRoutes PATCH(string, ...HandlerFunc) IRoutes PUT(string, ...HandlerFunc) IRoutes OPTIONS(string, ...HandlerFunc) IRoutes HEAD(string, ...HandlerFunc) IRoutes StaticFile(string, string) IRoutes StaticFileFS(string, string, http.FileSystem) IRoutes Static(string, string) IRoutes StaticFS(string, http.FileSystem) IRoutes } 3. gin.node 路由树 在 Gin 框架中，路由规则被分成了最多 9 棵前缀树，每一个 HTTP Method 对应一棵「前缀树」，树的节点按照 URL 中的 / 符号进行层级划分， URL 支持 :name 形式的名称匹配， 还支持 *subpath 形式的路径通配符 。\nGin的路由只需遍历一遍字符串即可，时间复杂度为O(n)。\nfunc New() *Engine { ... engine := \u0026amp;Engine{ ... trees: make(methodTrees, 0, 9), ... } } type node struct { path string // 当前节点相对路径（与祖先节点的 path 拼接可得到完整路径） indices string // 所以孩子节点的path[0]组成的字符串 wildChild bool // 孩子节点是否有通配符（wildcard） nType nodeType // 节点类型 priority uint32 // 当前节点及子孙节点的实际路由数量 children []*node // 孩子节点 handlers HandlersChain // 当前节点的处理函数（包括中间件） fullPath string // 当前节点完整路径 } 4. 示例 r.GET(\u0026#34;/\u0026#34;, func (context *gin.Context) {}) r.GET(\u0026#34;/index\u0026#34;, func (context *gin.Context) {}) r.GET(\u0026#34;/inter\u0026#34;, func (context *gin.Context) {}) r.GET(\u0026#34;/go\u0026#34;, func (context *gin.Context) {}) r.GET(\u0026#34;/game/:id/doc\u0026#34;, func (context *gin.Context) {}) flowchart TB / --\u003e in / --\u003e g in --\u003e dex in --\u003e ter g --\u003e o g --\u003e ame ame --\u003e :id :id --\u003e doc\r3、路由过程 func (engine *Engine) handleHTTPRequest(c *Context) { ... // Find root of the tree for the given HTTP method t := engine.trees for i, tl := 0, len(t); i \u0026lt; tl; i++ { // 过滤method if t[i].method != httpMethod { continue } root := t[i].root // Find route in tree // 匹配最佳路由 value := root.getValue(rPath, c.params, c.skippedNodes, unescape) if value.params != nil { c.Params = *value.params } if value.handlers != nil { c.handlers = value.handlers c.fullPath = value.fullPath c.Next() c.writermem.WriteHeaderNow() return } if httpMethod != http.MethodConnect \u0026amp;\u0026amp; rPath != \u0026#34;/\u0026#34; { if value.tsr \u0026amp;\u0026amp; engine.RedirectTrailingSlash { redirectTrailingSlash(c) return } if engine.RedirectFixedPath \u0026amp;\u0026amp; redirectFixedPath(c, root, engine.RedirectFixedPath) { return } } break } ... } func (n *node) getValue(path string, params *Params, skippedNodes *[]skippedNode, unescape bool) (value nodeValue) { var globalParamsCount int16 walk: // Outer loop for walking the tree for { prefix := n.path // if len(path) \u0026gt; len(prefix) { if path[:len(prefix)] == prefix { path = path[len(prefix):] // Try all the non-wildcard children first by matching the indices idxc := path[0] for i, c := range []byte(n.indices) { if c == idxc { // strings.HasPrefix(n.children[len(n.children)-1].path, \u0026#34;:\u0026#34;) == n.wildChild if n.wildChild { index := len(*skippedNodes) *skippedNodes = (*skippedNodes)[:index+1] (*skippedNodes)[index] = skippedNode{ path: prefix + path, node: \u0026amp;node{ path: n.path, wildChild: n.wildChild, nType: n.nType, priority: n.priority, children: n.children, handlers: n.handlers, fullPath: n.fullPath, }, paramsCount: globalParamsCount, } } n = n.children[i] continue walk } } if !n.wildChild { // If the path at the end of the loop is not equal to \u0026#39;/\u0026#39; and the current node has no child nodes // the current node needs to roll back to last valid skippedNode if path != \u0026#34;/\u0026#34; { for l := len(*skippedNodes); l \u0026gt; 0; { skippedNode := (*skippedNodes)[l-1] *skippedNodes = (*skippedNodes)[:l-1] if strings.HasSuffix(skippedNode.path, path) { path = skippedNode.path n = skippedNode.node if value.params != nil { *value.params = (*value.params)[:skippedNode.paramsCount] } globalParamsCount = skippedNode.paramsCount continue walk } } } // Nothing found. // We can recommend to redirect to the same URL without a // trailing slash if a leaf exists for that path. value.tsr = path == \u0026#34;/\u0026#34; \u0026amp;\u0026amp; n.handlers != nil return } // Handle wildcard child, which is always at the end of the array n = n.children[len(n.children)-1] globalParamsCount++ switch n.nType { case param: // fix truncate the parameter // tree_test.go line: 204 // Find param end (either \u0026#39;/\u0026#39; or path end) end := 0 for end \u0026lt; len(path) \u0026amp;\u0026amp; path[end] != \u0026#39;/\u0026#39; { end++ } // Save param value if params != nil \u0026amp;\u0026amp; cap(*params) \u0026gt; 0 { if value.params == nil { value.params = params } // Expand slice within preallocated capacity i := len(*value.params) *value.params = (*value.params)[:i+1] val := path[:end] if unescape { if v, err := url.QueryUnescape(val); err == nil { val = v } } (*value.params)[i] = Param{ Key: n.path[1:], Value: val, } } // we need to go deeper! if end \u0026lt; len(path) { if len(n.children) \u0026gt; 0 { path = path[end:] n = n.children[0] continue walk } // ... but we can\u0026#39;t value.tsr = len(path) == end+1 return } if value.handlers = n.handlers; value.handlers != nil { value.fullPath = n.fullPath return } if len(n.children) == 1 { // No handle found. Check if a handle for this path + a // trailing slash exists for TSR recommendation n = n.children[0] value.tsr = (n.path == \u0026#34;/\u0026#34; \u0026amp;\u0026amp; n.handlers != nil) || (n.path == \u0026#34;\u0026#34; \u0026amp;\u0026amp; n.indices == \u0026#34;/\u0026#34;) } return case catchAll: // Save param value if params != nil { if value.params == nil { value.params = params } // Expand slice within preallocated capacity i := len(*value.params) *value.params = (*value.params)[:i+1] val := path if unescape { if v, err := url.QueryUnescape(path); err == nil { val = v } } (*value.params)[i] = Param{ Key: n.path[2:], Value: val, } } value.handlers = n.handlers value.fullPath = n.fullPath return default: panic(\u0026#34;invalid node type\u0026#34;) } } } if path == prefix { // If the current path does not equal \u0026#39;/\u0026#39; and the node does not have a registered handle and the most recently matched node has a child node // the current node needs to roll back to last valid skippedNode if n.handlers == nil \u0026amp;\u0026amp; path != \u0026#34;/\u0026#34; { for l := len(*skippedNodes); l \u0026gt; 0; { skippedNode := (*skippedNodes)[l-1] *skippedNodes = (*skippedNodes)[:l-1] if strings.HasSuffix(skippedNode.path, path) { path = skippedNode.path n = skippedNode.node if value.params != nil { *value.params = (*value.params)[:skippedNode.paramsCount] } globalParamsCount = skippedNode.paramsCount continue walk } } //\tn = latestNode.children[len(latestNode.children)-1] } // We should have reached the node containing the handle. // Check if this node has a handle registered. if value.handlers = n.handlers; value.handlers != nil { value.fullPath = n.fullPath return } // If there is no handle for this route, but this route has a // wildcard child, there must be a handle for this path with an // additional trailing slash if path == \u0026#34;/\u0026#34; \u0026amp;\u0026amp; n.wildChild \u0026amp;\u0026amp; n.nType != root { value.tsr = true return } // No handle found. Check if a handle for this path + a // trailing slash exists for trailing slash recommendation for i, c := range []byte(n.indices) { if c == \u0026#39;/\u0026#39; { n = n.children[i] value.tsr = (len(n.path) == 1 \u0026amp;\u0026amp; n.handlers != nil) || (n.nType == catchAll \u0026amp;\u0026amp; n.children[0].handlers != nil) return } } return } // Nothing found. We can recommend to redirect to the same URL with an // extra trailing slash if a leaf exists for that path value.tsr = path == \u0026#34;/\u0026#34; || (len(prefix) == len(path)+1 \u0026amp;\u0026amp; prefix[len(path)] == \u0026#39;/\u0026#39; \u0026amp;\u0026amp; path == prefix[:len(prefix)-1] \u0026amp;\u0026amp; n.handlers != nil) // roll back to last valid skippedNode if !value.tsr \u0026amp;\u0026amp; path != \u0026#34;/\u0026#34; { for l := len(*skippedNodes); l \u0026gt; 0; { skippedNode := (*skippedNodes)[l-1] *skippedNodes = (*skippedNodes)[:l-1] if strings.HasSuffix(skippedNode.path, path) { path = skippedNode.path n = skippedNode.node if value.params != nil { *value.params = (*value.params)[:skippedNode.paramsCount] } globalParamsCount = skippedNode.paramsCount continue walk } } } return } } ","permalink":"http://localhost:1313/posts/tech/gin/2-start-analyze/","summary":"1、服务启动过程 func main() { r := gin.Default() r.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;pong\u0026#34;, }) }) r.Run() } 1. gin.Default() gin.Default() 函数会生成一个默认的 Engine 对象，里面包含了 2 个默认的常用插件，分别是 Logger 和 Recover","title":"gin框架(二)、服务启动源码解析"},{"content":"","permalink":"http://localhost:1313/posts/life/one/","summary":"","title":"One"},{"content":"分层架构 Kubernetes 设计理念和功能其实就是一个类似 Linux 的分层架构\n核心层：Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执行环境 应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS 解析等） 管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态 Provision 等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy 等） 接口层：kubectl 命令行工具、客户端 SDK 以及集群联邦 生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴 Kubernetes 外部：日志、监控、配置管理、CI、CD、Workflow、FaaS、OTS 应用、ChatOps 等 Kubernetes 内部：CRI、CNI、CVI、镜像仓库、Cloud Provider、集群自身的配置和管理等 API 设计原则 对于云计算系统，系统 API 实际上处于系统设计的统领地位，正如本文前面所说，Kubernetes 集群系统每支持一项新功能，引入一项新技术， 一定会新引入对应的 API 对象，支持对该功能的管理操作，理解掌握的 API，就好比抓住了 Kubernetes 系统的牛鼻子。Kubernetes 系统 API 的设计有以下几条原则\n所有 API 应该是声明式的。 正如前文所说，声明式的操作，相对于命令式操作，对于重复操作的效果是稳定的，这对于容易出现数据丢失或重复的分布式环境来说是很重要的。 另外，声明式操作更容易被用户使用，可以使系统向用户隐藏实现的细节，隐藏实现的细节的同时，也就保留了系统未来持续优化的可能性。此外，声明式的 API，同时隐含了所有的 API 对象都是名词性质的，例如 Service、Volume 这些 API 都是名词，这些名词描述了用户所期望得到的一个目标分布式对象。\nAPI 对象是彼此互补而且可组合的。 这里面实际是鼓励 API 对象尽量实现面向对象设计时的要求，即 “高内聚，松耦合”，对业务相关的概念有一个合适的分解，提高分解出来的对象的可重用性。 事实上，Kubernetes 这种分布式系统管理平台，也是一种业务系统，只不过它的业务就是调度和管理容器服务。\n高层 API 以操作意图为基础设计。 如何能够设计好 API，跟如何能用面向对象的方法设计好应用系统有相通的地方，高层设计一定是从业务出发，而不是过早的从技术实现出发。因此，针对 Kubernetes 的高层 API 设计，一定是以 Kubernetes 的业务为基础出发，也就是以系统调度管理容器的操作意图为基础设计\n低层 API 根据高层 API 的控制需要设计。 设计实现低层 API 的目的，是为了被高层 API 使用，考虑减少冗余、提高重用性的目的，低层 API 的设计也要以需求为基础，要尽量抵抗受技术实现影响的诱惑。\n尽量避免简单封装，不要有在外部 API 无法显式知道的内部隐藏的机制。 简单的封装，实际没有提供新的功能，反而增加了对所封装 API 的依赖性。内部隐藏的机制也是非常不利于系统维护的设计方式，例如 StatefulSet 和 ReplicaSet，本来就是两种 Pod 集合，那么 Kubernetes 就用不同 API 对象来定义它们，而不会说只用同一个 ReplicaSet，内部通过特殊的算法再来区分这个 ReplicaSet 是有状态的还是无状态。\nAPI 操作复杂度与对象数量成正比。 这一条主要是从系统性能角度考虑，要保证整个系统随着系统规模的扩大，性能不会迅速变慢到无法使用，那么最低的限定就是 API 的操作复杂度不能超过 O(N)，N 是对象的数量，否则系统就不具备水平伸缩性了。\nAPI 对象状态不能依赖于网络连接状态。 由于众所周知，在分布式环境下，网络连接断开是经常发生的事情，因此要保证 API 对象状态能应对网络的不稳定，API 对象的状态就不能依赖于网络连接状态。 尽量避免让操作机制依赖于全局状态，因为在分布式系统中要保证全局状态的同步是非常困难的。\n控制机制设计原则 控制逻辑应该只依赖于当前状态。 这是为了保证分布式系统的稳定可靠，对于经常出现局部错误的分布式系统，如果控制逻辑只依赖当前状态，那么就非常容易将一个暂时出现故障的系统恢复到正常状态， 因为你只要将该系统重置到某个稳定状态，就可以自信的知道系统的所有控制逻辑会开始按照正常方式运行。\n假设任何错误的可能，并做容错处理。 在一个分布式系统中出现局部和临时错误是大概率事件。错误可能来自于物理系统故障，外部系统故障也可能来自于系统自身的代码错误， 依靠自己实现的代码不会出错来保证系统稳定其实也是难以实现的，因此要设计对任何可能错误的容错处理。\n尽量避免复杂状态机，控制逻辑不要依赖无法监控的内部状态。 因为分布式系统各个子系统都是不能严格通过程序内部保持同步的，所以如果两个子系统的控制逻辑如果互相有影响，那么子系统就一定要能互相访问到影响控制逻辑的状态， 否则，就等同于系统里存在不确定的控制逻辑。\n假设任何操作都可能被任何操作对象拒绝，甚至被错误解析。 由于分布式系统的复杂性以及各子系统的相对独立性，不同子系统经常来自不同的开发团队，所以不能奢望任何操作被另一个子系统以正确的方式处理， 要保证出现错误的时候，操作级别的错误不会影响到系统稳定性。\n每个模块都可以在出错后自动恢复。 由于分布式系统中无法保证系统各个模块是始终连接的，因此每个模块要有自我修复的能力，保证不会因为连接不到其他模块而自我崩溃。\n每个模块都可以在必要时优雅地降级服务。 所谓优雅地降级服务，是对系统鲁棒性的要求，即要求在设计实现模块时划分清楚基本功能和高级功能，保证基本功能不会依赖高级功能， 这样同时就保证了不会因为高级功能出现故障而导致整个模块崩溃。根据这种理念实现的系统，也更容易快速地增加新的高级功能，因为不必担心引入高级功能影响原有的基本功能。\nEtcd 解析 Etcd 是 Kubernetes 集群中的一个十分重要的组件，用f于保存集群所有的网络配置和对象的状态信息。 整个 Kubernetes 系统中一共有两个服务需要用到 etcd 用来协同和存储配置，分别是：\n网络插件 flannel、对于其它网络插件也需要用到 etcd 存储网络的配置信息 Kubernetes 本身，包括各种对象的状态和元信息配置\n","permalink":"http://localhost:1313/posts/tech/k8s/architecture/","summary":"分层架构 Kubernetes 设计理念和功能其实就是一个类似 Linux 的分层架构 核心层：Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执","title":"Kubernetes架构"},{"content":" 云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。 云原生的代表技术包括 容器、服务网格、微服务、不可变基础设施 和 声明式 API。 这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。——CNCF（云原生计算基金会）。\n云原生的设计理念 面向分布式设计（Distribution）：容器、微服务、API 驱动的开发； 面向配置设计（Configuration）：一个镜像，多个环境配置； 面向韧性设计（Resistancy）：故障容忍和自愈； 面向弹性设计（Elasticity）：弹性扩展和对环境变化（负载）做出响应； 面向交付设计（Delivery）：自动拉起，缩短交付时间； 面向性能设计（Performance）：响应式，并发和资源高效利用； 面向自动化设计（Automation）：自动化的 DevOps； 面向诊断性设计（Diagnosability）：集群级别的日志、metric 和追踪； 面向安全性设计（Security）：安全端点、API Gateway、端到端加密； 云计算介绍 云原生借了云计算的东风，没有云计算，自然没有云原生，云计算是云原生的基础。\n通俗的讲，云计算可以说是一种配置资源的方式，随着虚拟化技术，可持续交付，编排系统的快速发展及普及，应用上云已经是不可逆转的趋势。 云计算从宏观上按3层划分，即基础设施即服务(IaaS)、平台即服务(PaaS)、软件即服务(SaaS)为云原生提供了技术基础和方向指引，\nIaaS：这是为了想要建立自己的商业模式并进行自定义的客户，例如亚马逊的 EC2、S3 存储、Rackspace 虚拟机等都是 IaaS。 PaaS：工具和服务的集合，对于想用它来构建自己的应用程序或者想快速得将应用程序部署到生产环境而不必关心底层硬件的用户和开发者来说是特别有用的， 比如 Cloud Foundry、Google App Engine、Heroku 等。 SaaS：终端用户可以直接使用的应用程序。这个就太多，我们生活中用到的很多软件都是 SaaS 服务，只要基于互联网来提供的服务基本都是 SaaS 服务，有的服务是免费的，比如 Google Docs，还有更多的是根据我们购买的 Plan 和使用量付费，比如 GitHub、各种云存储。 真正的云化不仅仅是基础设施和平台的变化，应用也需要做出改变，摈弃传统的土方法，在架构设计、开发方式、部署维护等各个阶段和方面都基于云的特点，重新设计，从而建设全新的云化的应用，即云原生应用。\nKubernetes作为一个分布式集群管理系统，它的一个重要目标是：将适合的资源分配给适合的应用，满足对应用的QoS要求和获得最优的资源使用效率。\n","permalink":"http://localhost:1313/posts/tech/cloud_native/design/","summary":"云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。 云原生的代表技术包括 容器、服务网格、微服务、不可","title":"如何云原生"},{"content":"云原生概念 什么是云原生（Cloud Native）？伴随着云计算的高速发展，云原生的概念也是一直处于发展变化之中，到目前为止，并没有一个确切的定义。\n我们现在谈到云原生，更多的指的是一种文化，而不具象为哪些技术体系，** 凡是能够提高云上资源利用率和应用交付效率的行为或方式都是云原生的**。\n云计算的发展史就是一部云原生化的历史，\nKubernetes 开启了云原生的序幕，\n服务网格 Istio 的出现，引领了后 Kubernetes 时代的微服务，\nServerless 的兴起，使得云原生从基础设施层不断向应用架构层挺进，\n我们正处于一个云原生的新时代。\nPivotal 定义 Pivotal公司的Matt Stine于2013年首次提出云原生（CloudNative）的概念。2015年，云原生刚推广时，Matt Stine在《迁移到云原生架构》一书中定义了符合云原生架构的几个特征：\n符合 12 因素应用 面向微服务架构 自服务敏捷架构 基于 API 的协作 抗脆弱性 到了 2017 年，Matt Stine 在接受 InfoQ 采访时又改了口风，将云原生架构归纳为6个特质\n模块化 可观察 可部署 可测试 可替换 可处理 而Pivotal最新官网对云原生概括为4个要点：\nDevOps 持续交付 微服务 容器 CNCF 定义 2015 年 Google 主导成立了云原生计算基金会（CNCF），起初 CNCF 对云原生（Cloud Native）的定义包含以下三个方面：\n应用容器化 面向微服务架构 应用支持容器的编排调度（自动化管理） 到了 2018 年，随着近几年来云原生生态的不断壮大，所有主流云计算供应商都加入了该基金会，且从 Cloud Native Landscape 中 可以看出云原生有意蚕食原先非云原生应用的部分。CNCF 基金会中的会员以及容纳的项目越来越多，该定义已经限制了云原生生态的发展，CNCF 为云原生进行了重新定位。\n将 服务网格(Service Mesh) 和 声明式API 给加了进来。\n云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。\n这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。\n云原生计算基金会（CNCF）致力于培育和维护一个厂商中立的开源生态系统，来推广云原生技术。我们通过将最前沿的模式民主化，让这些创新为大众所用。\n总结 凡是能够提高云上资源利用率和应用交付效率的行为或方式都是云原生的。\n采用开源堆栈（K8S+Docker）进行容器化， 基于微服务架构提高灵活性和可维护性， 借助敏捷方法、DevOps支持持续迭代和运维自动化， 利用云平台设施实现弹性伸缩、动态调度、优化资源利用率。\n参考 云原生的定义\n什么是云原生\n","permalink":"http://localhost:1313/posts/tech/cloud_native/definition/","summary":"云原生概念 什么是云原生（Cloud Native）？伴随着云计算的高速发展，云原生的概念也是一直处于发展变化之中，到目前为止，并没有一个确切的","title":"云原生的定义"},{"content":"安装Golang 在Golang官网网站即可完成下载，链接：https://go.dev/dl/\nWindows下可以使用 .msi 后缀(在下载列表中可以找到该文件，如go1.19.2.windows-amd64.msi)的安装包来安装。\nlinux下安装示例\nwget https://go.dev/dl/go1.19.4.linux-amd64.tar.gz tar -C ~/Ruff/ -xzf go1.19.4.linux-amd64.tar.gz 安装完成后，在对应安装目录的 xxx\\bin 目录下打开cmd, 输入go version命令返回go version go1.19 windows/amd64即表示安装完成。\n配置环境变量 为方便使用，我们需要配置golang对应的环境变量\n新建环境变量GO_HOME: D:\\GO\\SDK\n编辑path变量，新增 %GO_HOME%\\bin\nlinux下 编辑 ~/.bash_profile 或者 /etc/profile\nexport PATH=$PATH:/usr/local/go/bin 添加后需要执行\nsource ~/.bash_profile 或 source /etc/profile Goland安装 官网下载最新版本https://www.jetbrains.com/go/download/\n有条件的可以支持正版\n无条件的参考破解攻略\nGo 私有仓库配置 go env设置\n国内仓库地址\ngo env -w GOPROXY=https://goproxy.cn,direct 私有仓库地址\ngo env -w GOPRIVATE=gitlab.xxx.xxx 若私仓为http则设置，否则CA证书验证不通过报错\ngo env -w GOINSECURE gitlab.xxx.xxx git配置 使用ssh\ngit config --global --add url.\u0026#34;ssh://xxxxx/\u0026#34;.insteadOf \u0026#34;http://xxxxxx/\u0026#34; ","permalink":"http://localhost:1313/posts/raiders/%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84/","summary":"安装Golang 在Golang官网网站即可完成下载，链接：https://go.dev/dl/ Windows下可以使用 .msi 后缀(在下载列表中可","title":"Golang 环境安装"},{"content":"node结构体 type node struct { path string // 当前节点相对路径（与祖先节点的 path 拼接可得到完整路径） indices string // 所以孩子节点的path[0]组成的字符串 wildChild bool // 孩子节点是否有通配符（wildcard） nType nodeType // 节点类型 priority uint32 // 当前节点及子孙节点的实际路由数量 children []*node // 孩子节点 handlers HandlersChain // 当前节点的处理函数（包括中间件） fullPath string // 当前节点完整路径 } 请求路由 r.GET(\u0026#34;/\u0026#34;, func (context *gin.Context) {}) r.GET(\u0026#34;/index\u0026#34;, func (context *gin.Context) {}) r.GET(\u0026#34;/inter\u0026#34;, func (context *gin.Context) {}) r.GET(\u0026#34;/go\u0026#34;, func (context *gin.Context) {}) r.GET(\u0026#34;/game/:id/doc\u0026#34;, func (context *gin.Context) {}) gin.node结构 Gin的路由实现使用了类似前缀树的数据结构，只需遍历一遍字符串即可，时间复杂度为O(n)。\nflowchart TB / --\u003e in / --\u003e g in --\u003e dex in --\u003e ter g --\u003e o g --\u003e ame ame --\u003e :id :id --\u003e doc\rclassDiagram Engine \u003c-- methodTree methodTree \u003c-- node class Engine{ +[]methodTree methodTrees +addRoute() +Handler() +Run() } class methodTree{ -string method -*node root } class node{ +string path +bool wildChild +uint8 nType +[]node children }\rhandlers handlers里存储了该节点对应路由下的所有处理函数，处理业务逻辑时是这样的\n// Next should be used only inside middleware. // It executes the pending handlers in the chain inside the calling handler. // See example in GitHub. func (c *Context) Next() { c.index++ for c.index \u0026lt; int8(len(c.handlers)) { c.handlers[c.index](c) c.index++ } } ","permalink":"http://localhost:1313/posts/tech/go_gin/","summary":"node结构体 type node struct { path string // 当前节点相对路径（与祖先节点的 path 拼接可得到完整路径） indices string // 所以孩子节点的path[0]组成的字符串 wildChild bool // 孩子节点","title":"Go_gin"},{"content":"关于我\n\u0026hellip;\n","permalink":"http://localhost:1313/about/","summary":"关于我 \u0026hellip;","title":"🙋🏻‍♂️关于"},{"content":"","permalink":"http://localhost:1313/posts/raiders/python_env/","summary":"","title":"Python环境安装"}]