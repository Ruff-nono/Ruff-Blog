---
title: "ssh-agent详解"
slug: ""
date: 2023-03-22T14:39:42+08:00
lastmod: 2023-03-22T14:39:42+08:00
author: ["路非非"]
tags: # 标签
- ssh
series:
-
description: ""
weight:
draft: false # 是否为草稿
comments: true # 本页面是否显示评论
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
math: true
cover:
  image: "" #图片路径例如：posts/tech/123/123.png
  caption: "" #图片底部描述
  alt: ""
  relative: false
---

# 什么是 ssh-agent
**ssh-agent命令**是一种控制用来保存公钥身份验证所使用的私钥的程序。`ssh-agent` 在X会话或登录会话之初启动，
所有其他窗口或程序则以客户端程序的身份启动并加入到ssh-agent程序中。通过使用环境变量，可定位代理并在登录到其他使用ssh机器上时使用代理自动进行身份验证。

`ssh-agent` 直白翻译ssh代理，可以理解为密钥管理器，用来管理一个或多个密钥，运行 `ssh-agent` 以后，使用 ssh-add 将私钥交给 `ssh-agent` 保管，
其他程序需要身份验证的时候可以将验证申请交给 `ssh-agent` 来完成整个认证过程。

使用 ssh-agent 的好处：  
* 当其他程序需要身份验证的时候，可以将验证申请交给 `ssh-agent` 来完成整个认证过程。当我们需要连接到不同的主机时，需要手动指定对应的密钥，而ssh代理可以自动帮助我们选择对应的密钥进行认证。
* 避免重复输入密码：如果您的私钥使用密码短语来加密了的话，每一次使用 SSH 密钥对进行登录的时候，您都必须输入正确的密码短语。而 SSH agent 程序能够将您的已解密的私钥缓存起来，在需要的时候提供给您的 SSH 客户端。这样子，您就只需要在使用 ssh-add 时将私钥加入 SSH agent 缓存的时候，输入一次密码短语就可以了。这为经常使用 SSH 连接用户提供了不少便利。

# 什么是ssh
安全外壳协议（Secure Shell Protocol，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。  
SSH通过在网络中创建安全隧道来实现SSH客户端与服务器之间的连接。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输命令行界面和远程执行命令。

在设计上，SSH是Telnet和非安全shell的替代品。`Telnet` 和 `Berkeley rlogin`、`rsh`、`rexec` 等协议采用明文传输，使用不可靠的密码，容易遭到监听、嗅探和中间人攻击。  
SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 `SSH` 协议 可以有效防止远程管理过程中的信息泄露问题。  
通过SSH可以对所有传输的数据进行加密，也能够防止 `DNS` 欺骗和 `IP` 欺骗。

# ssh的原理
SSH以非对称加密实现身份验证。通过生成一对公钥-私钥来加密网络连接。公钥放在待访问的服务器之中，对应的私钥由用户自行保管。认证过程基于生成出来的私钥，但整个认证过程中私钥本身不会传输到网络中。

那么问题又来了， 非对称加密为什么能保证安全呢？

## 非对称加密
首先我们举个栗子，Alice和Bob想要进行通信，而又不希望通信内容被其他人知道。所以他们商定了一种内容加密方式。  
1. 双方商定加密算法。
2. 双方确定密钥。
3. 通信内容通过密钥进行加解密。

这个方案看似很合理，外人不知道密钥就没法获得通信内容。  
但是这里有一个严重的漏洞，密钥既要让AliceBob都知道，又不能被外人知道，那怎么沟通确定密钥呢？  
如果Alice确定了密钥并需要告知对方，那这个告知的过程又可能泄密。

这里就引出另一个问题：**密钥配送问题**

密钥确定之后，想要告诉对方，但密钥本身属于信息，如果给密钥加密，那么就陷入了死循环。  
另外我们可能会想，即使密钥泄密，那不是还有加密算法能保证信息安全吗？这就涉及到密码学很重要的一个原则：**杜绝隐蔽式安全性**  
即任何算法最终都会被破解，所以现在流行的密码算法都是公开的，从诞生之初就没想通过保密算法来提高安全。

{{< innerlink src="read/encrypt.md" >}}

有以下几种解决密钥配送问题的方案：
1. 事先共享密钥 
2. 密钥分配中心 
3. Diffie-Hellman密钥交换 
4. 非对称加密

我们本次关注的是**非对称加密**方案

在对称加密中，我们只需要一个密钥，通信双方同时持有。而非对称加密需要一对公钥和私钥。  
其中公钥是公开的，由信息发送方保存，用于加密信息。  
私钥由信息接收方保存，用于解密信息。  
所以密钥一般由信息接收方生成，并将公钥交给信息发送方。  
并且由于公钥是公开的，所以不存在保密问题。也就是说非对称加密完全不存在密钥配送问题！

回到前面的栗子，Alice和Bob发现非对称加密不错，于是做了以下几件事情：
1. Alice确定了公钥和私钥，自己保留了私钥，将公钥交给了Bob
2. Bob发送信息 “周六下午公园小树林见”，并通过公钥对信息进行了加密。
3. Alice收到信息后通过私钥对信息进行解密（其他人即使拦截到了信息，由于没有私钥也无法解密信息）。

* 加密：公钥加密，私钥解密的过程，称为「加密」  
**因为公钥是公开的，任何公钥持有者都可以将想要发送给私钥持有者的信息进行加密后发送，而这个信息只有私钥持有者才能解密。用于保证消息不会被其他人获取。**
* 签名：私钥加密，公钥解密的过程，称为「签名」  
**相反，因为私钥是私有的，所以当收到的信息可以通过公钥解密时，那么就可以证明发送方一定是私钥持有者发布的。用于保证消息来源的准确性。**


公钥和私钥中的指数部分（e和d）是不同的。公钥指数（e）通常是一个较小的固定值，用于加密操作。私钥指数（d）是根据数学运算得到的，用于解密操作。

## 非对称加密算法
非对称加密算法主要包含RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）。  
而使用最广泛的是RSA算法。

维基百科
> 对极大整数做因数分解的难度决定了 RSA 算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，
> 那么用 RSA 加密的信息的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的 RSA 钥匙才可能被强力方式破解。到2020年为止，
> 世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被破解的。

**公钥和私钥的产生**
1. 随意选择两个大素数 p(61) 和 q(53) (pq越大越安全)，p≠q，计算 $$N = pq = 61 * 53 = 3233$$ N将成为RSA算法中的模数。
2. 根据欧拉函数，求得 $$\varphi(N) = (p - 1)(q - 1) = (61-1) * (53-1) = 3120$$
3. 选择一个小于 φ(n) 且与 φ(n) 互质的整数e作为公钥指数。常见的选择是使用65537（0x10001）作为e。
4. 求得 e 关于 φ(n) 的模反元素d，即，找到d使得 $$ed\equiv 1\pmod {r}$$ 可以使用扩展欧几里得算法来计算d。在我们的示例中，d = 2017。 
5. 将 p 和 q 的记录销毁。公钥由(n, e)组成，私钥由(n, d)组成。

因此，我们的RSA公钥为(3233, 65537)，私钥为(3233, 2017)。

**加解密消息**
1. 使用约定好的格式转换为整数M，确保转换后的整数满足0 ≤ M < N。
2. 通过公式 $$C = M^e\mod n$$进行加密计算。 在我们的例子中，C = 1234^65537 mod 3233 = 855
3. Bob将加密后的密文C（在我们的例子中为855）发送给Alice。 
4. 收到密文C后，使用她的私钥(n, d) = (3233, 2017)进行解密：
使用公式 $$M = C^d \mod n$$进行解密计算。
在我们的例子中，M = 855^2017 mod 3233 = 1234

**签名消息**  

RSA也可以用来为一个消息署名。假如Alice想给Bob传递一个署名的消息的话，那么她可以为她的消息计算一个散列值（Message digest），
然后用她的私钥“加密”（如同前面“加密消息”的步骤）这个散列值并将这个“署名”加在消息的后面。这个消息只有用她的公钥才能被解密。
Bob获得这个消息后可以用Alice的公钥“解密”（如同前面“解密消息”的步骤）这个散列值，然后将这个数据与他自己为这个消息计算的散列值相比较。
假如两者相符的话，那么Bob就可以知道发信人持有Alice的私钥，以及这个消息在传播路径上没有被篡改过。

